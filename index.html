<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mau Mau</title>

<style>
:root{
  --bg:#0b1220;
  --txt:#e6eefc;
  --muted:#9fb1d1;
  --accent:#64ffda;
  --danger:#ff5370;
  --warn:#ffd166;
  --ok:#7CFC00;
  --shadow: 0 12px 30px rgb(0 0 0 / .35);
  --radius:18px;
  --cardW:70px;
  --cardH:98px;
}

*{
  box-sizing:border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}
html,body{height:100%}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;
  background: radial-gradient(1000px 700px at 20% 0%, #13224a 0%, var(--bg) 55%, #070b14 100%);
  color:var(--txt);
  user-select:none;
  -webkit-user-select:none;
  overflow:hidden; /* body must NOT scroll */
}

/* Only scroll container -> reduces Huawei/Android overscroll blue overlay */
#scrollRoot{
  height:100vh;
  overflow:auto;
  -webkit-overflow-scrolling: touch;
  overscroll-behavior: none;
  padding:16px;
  display:flex;
  justify-content:center;
  touch-action: manipulation;
}
#scrollRoot::-webkit-scrollbar{ width:0; height:0; }

.app{
  width:min(980px, 100%);
  display:flex;
  flex-direction:column;
  gap:12px;
}

header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:14px 16px;
  background:linear-gradient(180deg, rgb(255 255 255 / 0.10), rgb(255 255 255 / 0.04));
  border:1px solid rgb(255 255 255 / 0.10);
  border-radius:var(--radius);
  box-shadow: var(--shadow);
}
header h1{
  font-size:16px;
  margin:0;
  letter-spacing:.4px;
  display:flex; align-items:center; gap:10px;
}
.badge{
  font-size:12px;
  padding:3px 8px;
  border-radius:999px;
  background:rgb(100 255 218 / 0.14);
  border:1px solid rgb(100 255 218 / 0.35);
  color:var(--accent);

  display:inline-flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  line-height:1.1;
}
.controls{ display:flex; align-items:center; gap:10px; }

button{
  appearance:none;
  border:none;
  padding:10px 12px;
  border-radius:12px;
  font-weight:600;
  background:rgb(255 255 255 / 0.08);
  color:var(--txt);
  border:1px solid rgb(255 255 255 / 0.12);
  cursor:pointer;
  transition:.15s transform, .15s background;
}
button:hover{ transform: translateY(-1px); background:rgb(255 255 255 / 0.12); }
button:active{ transform: translateY(0px); }
button.primary{
  background:rgb(100 255 218 / 0.16);
  border-color:rgb(100 255 218 / 0.35);
  color:var(--accent);
}
button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }
.small{ padding:8px 10px; font-size:12px; border-radius:10px; }

main{
  display:grid;
  gap:12px;
  grid-template-columns: 1.2fr 0.8fr;
}
@media (max-width: 820px){
  main{ grid-template-columns:1fr; }
}

.panel{
  background:linear-gradient(180deg, rgb(255 255 255 / 0.08), rgb(255 255 255 / 0.03));
  border:1px solid rgb(255 255 255 / 0.10);
  border-radius:var(--radius);
  box-shadow: var(--shadow);
  padding:14px;
  position:relative;
  overflow:hidden;
}

.row{
  display:flex;
  gap:12px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
}
.kpis{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  justify-content:center;
}
.kpi{
  background:rgb(255 255 255 / 0.06);
  border:1px solid rgb(255 255 255 / 0.10);
  border-radius:14px;
  padding:10px 12px;
  min-width:110px;
}
.kpi .label{ color:var(--muted); font-size:12px; }
.kpi .value{ font-size:18px; font-weight:800; margin-top:2px; }

.board{ display:flex; flex-direction:column; gap:12px; }
.area{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  flex-wrap:wrap;
}
.stack{ display:flex; gap:12px; align-items:center; }

.pile{
  width:var(--cardW);
  height:var(--cardH);
  border-radius:14px;
  background:rgb(255 255 255 / 0.07);
  border:1px solid rgb(255 255 255 / 0.12);
  display:flex;
  align-items:center;
  justify-content:center;
  box-shadow: 0 8px 18px rgb(0 0 0 / .25);
  position:relative;
}
.pile::after{
  display:none;
}
.deck{
  background:linear-gradient(135deg, rgb(100 255 218 / 0.10), rgb(255 255 255 / 0.05));
}
.deck .count{
  position:absolute;
  bottom:-10px;
  right:-10px;
  background:rgb(0 0 0 / 0.5);
  border:1px solid rgb(255 255 255 / 0.14);
  padding:6px 9px;
  border-radius:999px;
  font-size:14px;
  font-weight:900;
}

.card{
  width:var(--cardW);
  height:var(--cardH);
  border-radius:14px;
  background:linear-gradient(180deg, rgb(255 255 255 / 0.12), rgb(255 255 255 / 0.05));
  border:1px solid rgb(255 255 255 / 0.18);
  display:flex;
  flex-direction:column;
  justify-content:space-between;
  padding:8px;
  box-shadow: 0 10px 20px rgb(0 0 0 / .25);
}
.card .top, .card .bottom{
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:900;
}
.card .mid{
  flex:1;
  display:flex;
  align-items:center;
  justify-content:center;
}
.card.red{ color:#ff7aa2; }
.card.black{ color:#d9e2ff; }

.hand{
  display:flex;
  flex-wrap:wrap;
  gap:10px;
  padding:10px 0 2px;
}
.hand .card{
  cursor:pointer;
  transition:.12s transform, .12s filter, .12s opacity;
}
.hand .card:hover{ transform: translateY(-2px) scale(1.02); filter:brightness(1.05); }
.hand .card.unplayable{
  opacity:.35;
  filter: grayscale(.7);
  cursor:not-allowed;
}

.info{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
.tag{
  padding:6px 10px;
  border-radius:999px;
  font-size:12px;
  border:1px solid rgb(255 255 255 / 0.14);
  background:rgb(255 255 255 / 0.06);
  color:var(--muted);
  display:flex;
  align-items:center;
  gap:6px;
}
.tag strong{ color:var(--txt); }

.status{
  margin-top:8px;
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgb(255 255 255 / 0.10);
  background:rgb(255 255 255 / 0.05);
  color:var(--muted);
  font-weight:650;
}
.status.ok{ border-color:rgb(124 252 0 / 0.35); color:#c7ff9b; background:rgb(124 252 0 / 0.07); }
.status.warn{ border-color:rgb(255 209 102 / 0.45); color:#ffe8b6; background:rgb(255 209 102 / 0.07); }
.status.danger{ border-color:rgb(255 83 112 / 0.45); color:#ffdbe3; background:rgb(255 83 112 / 0.07); }

/* SVG suit icons */
.suit{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:18px;
  height:18px;
}
.suit svg{ width:18px; height:18px; display:block; fill:currentColor; }
.suit.big{ width:36px; height:36px; }
.suit.big svg{ width:36px; height:36px; }

.modal{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgb(0 0 0 / 0.78);
  padding:18px;
  z-index:50;
}
.modal.open{ display:flex; }
.modal .box{
  background:rgba(18, 28, 52, 0.95);
  border:1px solid rgb(255 255 255 / 0.18);
  border-radius:22px;
  box-shadow: var(--shadow);
  padding:16px;
}
.modal h2{ margin:0 0 10px; font-size:16px; }

.choices{ display:flex; gap:10px; flex-wrap:wrap; }
.choice{
  flex:1;
  min-width:92px;
  padding:12px;
  border-radius:16px;
  border:1px solid rgb(255 255 255 / 0.16);
  background:rgb(255 255 255 / 0.06);
  cursor:pointer;
  display:flex;
  justify-content:space-between;
  font-weight:900;
}
.choice:hover{ background:rgb(255 255 255 / 0.10); }

.kpi-you{ position:relative; }
.kpi-bot{ position:relative; }

.mau{
  position:absolute;
  right:10px;
  top:10px;
  padding:6px 10px;
  border-radius:14px;
  background:rgb(255 209 102 / 0.18);
  border:1px solid rgb(255 209 102 / 0.45);
  font-weight:900;
  color:var(--warn);
  display:none;
  z-index:5;
}
.mau.show{ display:block; }
</style>
</head>

<body>
<div id="scrollRoot">
  <div class="app">
    <header>
   <h1>Mau Mau<span class="badge">Offline Player</span></h1>
      <div class="controls">
        <button class="small primary" id="btnNew">Neues Spiel</button>
        <button class="small" id="btnHelp">Regeln</button>
      </div>
    </header>

    <main>
      <section class="panel board">

        <div class="row">
          <div class="kpis">
            <div class="kpi kpi-you">
  <div class="label">Du</div>
  <div class="value" id="kpiYou">0</div>
  <div class="mau" id="mauYou">Mau!</div>
</div>
            <div class="kpi kpi-bot"><div class="label">Bot</div><div class="value" id="kpiBot">0</div><div class="mau" id="mauBot">Mau!</div></div>
          </div>

          <div class="info">
            <div class="tag" id="tagTurn"><strong>Zug:</strong> Du</div>
            <div class="tag" id="tagWish"><strong>Wunsch:</strong> -</div>
            <div class="tag" id="tagPenalty"><strong>Strafe:</strong> 0</div>
          </div>
        </div>

        <div class="area">
          <div class="stack">
           
            <div class="pile deck" id="deckPile" title="Klicken zum Ziehen">
              <div style="font-weight:900;opacity:.85;">Stapel</div>
              <div class="count" id="deckCount">0</div>
            </div>
            <div class="pile" id="discardTop" title="Ablagestapel"></div>
          </div>

          <div class="controls">
            <button class="primary" id="btnDraw">Ziehen</button>
            <button id="btnPass">Passen</button>
          </div>
        </div>

        <div class="status" id="status">Bereit.</div>

        <div style="margin-top:8px; color:var(--muted); font-size:12px;">
          Tipp: Klicke eine Karte zum Ausspielen. Unspielbare Karten sind ausgegraut.
        </div>
      </section>

      <section class="panel">
        <h2 style="margin:0 0 8px; font-size:16px;">Deine Hand</h2>
        <div class="hand" id="hand"></div>
      </section>
    </main>
  </div>
</div>

<div class="modal" id="wishModal" aria-hidden="true">
  <div class="box">
    <h2>Wähle eine Wunschfarbe</h2>
    <div class="choices" id="wishChoices"></div>
    <div style="margin-top:12px; color:var(--muted); font-size:12px;">
      Du hast einen Buben gespielt. Jetzt bestimmst du die nächste Farbe.
    </div>
  </div>
</div>

<div class="modal" id="helpModal" aria-hidden="true">
  <div class="box">
    <h2>Regeln</h2>
    <div style="color:var(--muted); font-size:13px; line-height:1.55;">
      <ul style="margin:8px 0 0; padding-left:18px;">
        <li>Du darfst eine Karte legen, wenn Farbe oder Wert passt.</li>
        <li><strong>7</strong>: Der nächste Spieler muss +2 ziehen. Mehrere 7en können gestapelt werden.</li>
        <li><strong>8</strong>: Der nächste Spieler setzt aus.</li>
        <li><strong>Bube</strong>: Wunschfarbe wählen.</li>
        <li>Wenn du keine Karte legen kannst: Du musst 1 Karte ziehen. Danach darfst du legen oder passen.</li>
      </ul>
    </div>
    <div style="margin-top:14px; display:flex; justify-content:flex-end;">
      <button class="primary" id="btnCloseHelp">OK</button>
    </div>
  </div>
</div>

<script>
const SUITS = [
  {key:"S", name:"Pik",   color:"black"},
  {key:"H", name:"Herz",  color:"red"},
  {key:"D", name:"Karo",  color:"red"},
  {key:"C", name:"Kreuz", color:"black"},
];
const RANKS = ["7","8","9","10","J","Q","K","A"];
const LABELS = {A:"A", K:"K", Q:"D", J:"B", "10":"10","9":"9","8":"8","7":"7"};

let deck = [];
let discard = [];
let you = [];
let bot = [];
let turn = "you";
let wish = "";
let penalty = 0;
let skipNext = false;
let waitingWish = false;
let gameOver = false;
let drewThisTurn = false;

function topDiscard(){ return discard.length ? discard[discard.length - 1] : null; }
function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
}
function label(r){ return LABELS[r] || r; }
function suitColor(k){ const s = SUITS.find(x=>x.key===k); return s ? s.color : "black"; }
function suitName(k){ const s = SUITS.find(x=>x.key===k); return s ? s.name : ""; }

/* Symmetric suits, no artifacts */
function suitSVG(key, size="small"){
  const color = suitColor(key);
  const cssColor = (color === "red") ? "#ff7aa2" : "#d9e2ff";
  const cls = `suit ${size==="big" ? "big" : ""}`;

  let inner = "";
  if(key === "D"){
    inner = `<polygon points="12,2 21,12 12,22 3,12"></polygon>`;
  } else if(key === "H"){
    inner = `<path d="M12 21S4 16.2 4 10.8C4 8.2 5.8 6.2 8.2 6.2C9.8 6.2 11.1 7 12 8.3C12.9 7 14.2 6.2 15.8 6.2C18.2 6.2 20 8.2 20 10.8C20 16.2 12 21 12 21Z"></path>`;
  } else if(key === "S"){
    inner = `
      <path d="M12 2C7.2 6.9 4 10.4 4 13.8C4 16.4 6.1 18.4 8.7 18.4C10.3 18.4 11.4 17.7 12 16.8C12.6 17.7 13.7 18.4 15.3 18.4C17.9 18.4 20 16.4 20 13.8C20 10.4 16.8 6.9 12 2Z"></path>
      <path d="M11 14.8h2v3.8h2v2H9v-2h2z"></path>
    `;
  } else { // C
    inner = `
      <circle cx="12" cy="7.8" r="4.1"></circle>
      <circle cx="8.2" cy="12.2" r="4.1"></circle>
      <circle cx="15.8" cy="12.2" r="4.1"></circle>
      <path d="M11 14.6h2v4h2v2H9v-2h2z"></path>
    `;
  }

  return `<span class="${cls}" style="color:${cssColor}">
    <svg viewBox="0 0 24 24" aria-hidden="true">${inner}</svg>
  </span>`;
}

function setStatus(text, mode="neutral"){
  const el = document.getElementById("status");
  el.classList.remove("ok","warn","danger");
  if(mode==="ok") el.classList.add("ok");
  if(mode==="warn") el.classList.add("warn");
  if(mode==="danger") el.classList.add("danger");
  el.textContent = text;
}

function buildDeck(){
  const a=[];
  for(const s of SUITS){
    for(const r of RANKS){
      a.push({suit:s.key, rank:r, color:s.color});
    }
  }
  shuffle(a);
  return a;
}

function drawCard(player){
  if(gameOver) return null;

  // Wenn Deck leer ist: Ablagestapel recyceln (ohne oberste Karte)
  if(deck.length === 0){
    // Wenn es keinen "Rest" gibt, kann man nicht mehr ziehen
    if(discard.length <= 1){
      setStatus("Keine Karten mehr zum Ziehen. Spiel ist beendet.", "danger");
      gameOver = true;
      render();
      return null;
    }

    const top = topDiscard();
    const rest = discard.slice(0, discard.length - 1);
    shuffle(rest);
    deck = rest;
    discard = [top];
  }

  // Falls nach Recycle trotzdem nichts da ist
  if(deck.length === 0){
    setStatus("Keine Karten mehr zum Ziehen. Spiel ist beendet.", "danger");
    gameOver = true;
    render();
    return null;
  }

  const c = deck.pop();
  player.push(c);
  return c;
}

function isPlayable(c){
  const top = topDiscard();
  if(!top) return true;
  if(penalty > 0) return c.rank === "7";
  if(wish) return (c.suit === wish) || (c.rank === "J");
  return (c.suit === top.suit) || (c.rank === top.rank) || (c.rank === "J");
}

function youHasPlayable(){ return you.some(isPlayable); }
function botHasPlayable(){ return bot.some(isPlayable); }

function checkWin(){
  if(you.length===0){ gameOver = true; setStatus("Du hast gewonnen!", "ok"); }
  else if(bot.length===0){ gameOver = true; setStatus("Bot hat gewonnen!", "danger"); }
}

/* Turn governance: clear feedback + enforce draw-if-no-play */
function onTurnChanged(){
  if(gameOver) return;

  if(turn === "you"){
    // Spielerführung, aber KEIN Automatismus
    if(!waitingWish && penalty===0 && !youHasPlayable() && !drewThisTurn){
      setStatus("Keine Karte spielbar. Bitte ziehe 1 Karte.", "warn");
    } else {
      setStatus("Du bist am Zug.", "neutral");
    }
  } else {
    setStatus("Bot ist am Zug.", "neutral");
  }
}

function botChooseWishKey(){
  const counts = {S:0, H:0, D:0, C:0};
  for(const c of bot){ counts[c.suit] = (counts[c.suit]||0) + 1; }
  let best="S";
  for(const k of ["S","H","D","C"]){ if(counts[k] > counts[best]) best = k; }
  return best;
}

function openWish(){
  const modal = document.getElementById("wishModal");
  const box = document.getElementById("wishChoices");
  box.innerHTML = "";

  for(const s of SUITS){
    const div = document.createElement("div");
    div.className="choice";
    div.innerHTML = `<span>${s.name}</span>${suitSVG(s.key)}`;
    div.onclick = ()=> chooseWish(s.key);
    box.appendChild(div);
  }

  modal.classList.add("open");
  modal.setAttribute("aria-hidden","false");
}

function closeWish(){
  const modal = document.getElementById("wishModal");
  modal.classList.remove("open");
  modal.setAttribute("aria-hidden","true");
}

function chooseWish(suit){
  wish = suit;
  waitingWish = false;
  closeWish();

  setStatus("Wunschfarbe gewählt: " + suitName(suit) + ".", "warn");
  render();

  // Zug beenden: nach Bube + Wunschfarbe ist der Gegner dran
  advanceTurnAfterPlay("you");
}

function applyCardEffect(card, who){
  if(card.rank === "7"){
    penalty += 2;
    setStatus("7 gelegt: Strafe jetzt +" + penalty, "warn");
  } else if(card.rank === "8"){
    skipNext = true;
    setStatus("8 gelegt: Nächster Spieler setzt aus.", "warn");
  } else if(card.rank === "J"){
    if(who === "you"){ waitingWish = true; openWish(); }
    else { wish = botChooseWishKey(); waitingWish = false; }
  }
}

function startGame(){
  deck = buildDeck();
  discard = [];
  you = [];
  bot = [];
  turn = "you";
  wish = "";
  penalty = 0;
  skipNext = false;
  waitingWish = false;
  gameOver = false;
  drewThisTurn = false;

  for(let i=0;i<5;i++){ drawCard(you); drawCard(bot); }

  let first = deck.pop();
  while(first.rank==="J"){
    deck.unshift(first);
    shuffle(deck);
    first = deck.pop();
  }
  discard.push(first);

  render();
  onTurnChanged();
}

function playCard(idx){
  if(gameOver || turn!=="you" || waitingWish) return;

  const c = you[idx];
  if(!isPlayable(c)) return;

  you.splice(idx,1);
  discard.push(c);

  // falls Wunschfarbe aktiv war und du KEINEN Buben legst -> Wunsch löschen
  if(wish && c.rank!=="J") wish = "";

  // ✅ WICHTIG: Wenn du keine Karten mehr hast, ist sofort Schluss.
  // Kein Wunschfarben-Dialog mehr, auch wenn es ein Bube war.
  if(you.length === 0){
    waitingWish = false;
    closeWish();              // schadet nie, verhindert Overlay
    render();
    checkWin();
    return;
  }

  applyCardEffect(c, "you");
  render();
  checkWin();
  if(gameOver) return;

  if(c.rank==="J"){
    waitingWish = true;
    openWish();
    return;
  }

  advanceTurnAfterPlay("you");
}

function advanceTurnAfterPlay(currentPlayer){
  // Standard: after a play/draw that ends the action, the other player is next
  const other = (currentPlayer==="you") ? "bot" : "you";
  turn = other;
  drewThisTurn = false;

  // 8 = skip the next player's turn -> currentPlayer plays again
  if(skipNext){
    skipNext = false;
    turn = currentPlayer;
    setStatus("Aussetzen! Gegner setzt aus.", "warn");
  }

  render();
  onTurnChanged();

  if(turn==="bot" && !gameOver) setTimeout(botTurn, 450);
}

function youDraw(){
  if(gameOver || turn!=="you" || waitingWish) return;

  // penalty handling: du MUSST ziehen, aber danach darfst du (wenn möglich) noch 1 Karte legen oder passen
if(penalty > 0){
  const n = penalty;
  for(let i=0;i<n;i++){
    const c = drawCard(you);
    if(!c) return; // gameOver wurde gesetzt
  }
  penalty = 0;
  drewThisTurn = true; // du hast gezogen (mehrfach) -> kein weiteres Ziehen in diesem Zug
  render();

  if(youHasPlayable()){
    setStatus("Strafe gezogen: +" + n + " Karten. Du darfst jetzt eine Karte legen oder passen.", "warn");
    return; // bleibst am Zug
  } else {
    setStatus("Strafe gezogen: +" + n + " Karten. Keine Karte spielbar.", "warn");
    advanceTurnAfterPlay("you");
    return;
  }
}

  // only once per normal turn
  if(drewThisTurn){
    setStatus("Du darfst pro Zug nur 1 Karte ziehen.", "danger");
    return;
  }

  const drawn = drawCard(you);
if(!drawn) return; // gameOver wurde gesetzt
drewThisTurn = true;
render();

  if(youHasPlayable()){
    // Standard Mau-Mau: after drawing and being able to play, you should play (no pass)
    setStatus("Du ziehst 1 Karte. Du darfst jetzt legen oder passen.", "warn");
  } else {
    // Still nothing playable -> turn ends automatically
    setStatus("Du ziehst 1 Karte. Keine Karte spielbar – Zug geht an Bot.", "warn");
    advanceTurnAfterPlay("you");
  }
}

function youPass(){
  if(gameOver || turn!=="you" || waitingWish) return;

  if(penalty > 0){
    setStatus("Bei Strafe musst du ziehen.", "danger");
    return;
  }

  if(!drewThisTurn){
    setStatus("Passen geht erst, nachdem du 1 Karte gezogen hast.", "danger");
    return;
  }

  setStatus("Du passt. Bot ist am Zug.", "neutral");
  advanceTurnAfterPlay("you");
}

function botTurn(){
  if(gameOver || turn!=="bot") return;

  if(penalty > 0){
    const idx = bot.findIndex(c=>c.rank==="7");
    if(idx >= 0){
      const c = bot.splice(idx,1)[0];
      discard.push(c);
      applyCardEffect(c, "bot");
      render();
      checkWin();
      if(gameOver) return;
      advanceTurnAfterPlay("bot");
      return;
    } else {
    const n = penalty;
    for(let i=0;i<n;i++){
      if(!drawCard(bot)) return;
    }
    penalty = 0;
    render();

    // Nach Strafe darf der Bot (wenn möglich) noch eine Karte legen, sonst endet sein Zug.
    const playableAfterPenalty = bot.map((c,i)=> isPlayable(c) ? i : -1).filter(i=>i>=0);
    if(playableAfterPenalty.length > 0){
      const idx2 = playableAfterPenalty[Math.floor(Math.random()*playableAfterPenalty.length)];
      const c2 = bot.splice(idx2,1)[0];
      discard.push(c2);

      if(wish && c2.rank!=="J") wish = "";
      applyCardEffect(c2, "bot");

      setStatus("Bot zieht Strafe (+" + n + ") und legt.", "warn");
      render();
      checkWin();
      if(gameOver) return;
      advanceTurnAfterPlay("bot");
      return;
    } else {
      setStatus("Bot zieht Strafe: +" + n + ". Keine Karte spielbar.", "warn");
      advanceTurnAfterPlay("bot");
      return;
    }
    }
  }

  const playableIdx = bot.map((c,i)=> isPlayable(c) ? i : -1).filter(i=>i>=0);
  if(playableIdx.length > 0){
    const idx = playableIdx[Math.floor(Math.random()*playableIdx.length)];
    const c = bot.splice(idx,1)[0];
    discard.push(c);

    if(wish && c.rank!=="J") wish = "";
    applyCardEffect(c, "bot");

    setStatus(c.rank==="J" ? "Bot legt Bube." : "Bot legt eine Karte.", c.rank==="J" ? "warn" : "neutral");

    render();
    checkWin();
    if(gameOver) return;
    advanceTurnAfterPlay("bot");
    return;
  }

  // draw once
  const d = drawCard(bot);
if(!d) return;
render();

if(isPlayable(d)){
    bot.pop();
    discard.push(d);

    if(wish && d.rank!=="J") wish = "";
    applyCardEffect(d, "bot");

    setStatus("Bot zieht 1 Karte und legt sie.", "neutral");
    render();
    checkWin();
    if(gameOver) return;
    advanceTurnAfterPlay("bot");
  } else {
    setStatus("Bot zieht 1 Karte.", "neutral");
    advanceTurnAfterPlay("bot");
  }
}

function render(){
  document.getElementById("kpiYou").textContent = you.length;
  document.getElementById("kpiBot").textContent = bot.length;
  document.getElementById("deckCount").textContent = deck.length;

  document.getElementById("tagTurn").innerHTML = `<strong>Zug:</strong> ${turn==="you" ? "Du" : "Bot"}`;
  document.getElementById("tagWish").innerHTML = `<strong>Wunsch:</strong> ${wish ? suitSVG(wish) : "-"}`;
  document.getElementById("tagPenalty").innerHTML = `<strong>Strafe:</strong> ${penalty}`;

  const mauYou = document.getElementById("mauYou");
  const mauBot = document.getElementById("mauBot");
  if(mauYou){
    if(you.length===1 && !gameOver){ mauYou.classList.add("show"); mauYou.textContent = "Mau!"; }
    else { mauYou.classList.remove("show"); }
  }
  if(mauBot){
    if(bot.length===1 && !gameOver){ mauBot.classList.add("show"); mauBot.textContent = "Mau!"; }
    else { mauBot.classList.remove("show"); }
  }

  const top = topDiscard();
  document.getElementById("discardTop").innerHTML = `
    <div class="card ${top.color}">
      <div class="top"><span>${label(top.rank)}</span>${suitSVG(top.suit)}</div>
      <div class="mid">${suitSVG(top.suit,"big")}</div>
      <div class="bottom">${suitSVG(top.suit)}<span>${label(top.rank)}</span></div>
    </div>
  `;

  const hand = document.getElementById("hand");
  hand.innerHTML = "";
  you.forEach((c,i)=>{
    const playable = isPlayable(c) && turn==="you" && !waitingWish && !gameOver;
    const div = document.createElement("div");
    div.className = "card " + c.color + (playable ? "" : " unplayable");
    div.innerHTML = `
      <div class="top"><span>${label(c.rank)}</span>${suitSVG(c.suit)}</div>
      <div class="mid">${suitSVG(c.suit,"big")}</div>
      <div class="bottom">${suitSVG(c.suit)}<span>${label(c.rank)}</span></div>
    `;
    div.onclick = ()=> playCard(i);
    hand.appendChild(div);
  });

  // Draw enabled rules
  const drawDisabled =
    (turn!=="you" || waitingWish || gameOver ||
     (penalty===0 && drewThisTurn)); // 1x draw limit

  document.getElementById("btnDraw").disabled = drawDisabled;
  document.getElementById("deckPile").style.pointerEvents = drawDisabled ? "none" : "auto";
  document.getElementById("deckPile").style.opacity = drawDisabled ? "0.6" : "1";

// Pass allowed if:
// - you can play (strategic pass) OR
// - you already drew once this turn
// BUT: if you cannot play and haven't drawn yet, pass is NOT allowed
const passEnabled =
  (turn==="you" && !waitingWish && !gameOver && penalty===0 &&
   drewThisTurn);

  document.getElementById("btnPass").disabled = !passEnabled;
}

document.getElementById("btnNew").onclick = startGame;
document.getElementById("btnDraw").onclick = youDraw;
document.getElementById("btnPass").onclick = youPass;
document.getElementById("deckPile").onclick = youDraw;

document.getElementById("btnHelp").onclick = ()=>{
  const m = document.getElementById("helpModal");
  m.classList.add("open");
  m.setAttribute("aria-hidden","false");
};
document.getElementById("btnCloseHelp").onclick = ()=>{
  const m = document.getElementById("helpModal");
  m.classList.remove("open");
  m.setAttribute("aria-hidden","true");
};

startGame();
</script>
</body>
</html>